%% NuMIT_PhiID
% 
% Returns the quantile of a set of PhiID atoms with respect to the null model.
% 
% Description:
%   This function computes the quantile values for PhiID atoms based on a specified null model. The input atoms 
%   are provided as a cell array of structs, and the function returns the quantiles by comparing them to the 
%   PhiID atoms generated from the null model.
% 
% Inputs:
%   atoms    - {L} cell array of structs containing the PhiID atoms for which the quantile is computed. Each struct contains the following fields:
%              rtr - {1}{2}->{1}{2} atom
%              rtx - {1}{2}->{1} atom
%              rty - {1}{2}->{2} atom
%              rts - {1}{2}->{12} atom
%              xtr - {1}->{1}{2} atom
%              xtx - {1}->{1} atom
%              xty - {1}->{2} atom
%              xts - {1}->{12} atom
%              ytr - {2}->{1}{2} atom
%              ytx - {2}->{1} atom
%              yty - {2}->{2} atom
%              yts - {2}->{12} atom
%              str - {12}->{1}{2} atom
%              stx - {12}->{1} atom
%              sty - {12}->{2} atom
%              sts - {12}->{12} atom
%   MI       - [L] array of total mutual information values.
%   model    - Struct with the following fields:
%              name  - "VAR", name of the model (currently, only "VAR" is supported).
%              S     - Number of sources.
%              T     - Number of targets.
%              n     - Number of iterations of the null model for each set of PhiID atoms.
%              p     - [L] array of model orders.
% 
% Outputs:
%   qPhiIDs  - [16, L] matrix of quantile values for the atoms computed with the null model, ordered as listed in the `atoms` input.
%   nPhiIDs  - {L} cell array, where each entry is a {N} cell array of distributions of N samples of a set of PhiID atoms generated by the null model.
% 
% Notes:
%   - VAR procedures only support model order p=1.
%
% Alberto Liardi, 2024


function [qPhiIDs, nPhiIDs] = NuMIT_PhiID(atoms, MI, model)

    if isfield(model, 'p')
        assert(length(MI)==length(model.p));
    else 
        model.p=ones(length(MI));
    end
    if ~isfield(model, 'n'), model.n=[]; end
    if ~isfield(model, 'S'), model.S=2; end
    if ~isfield(model, 'T'), model.T=1; end
    
    nPhiIDs = cell(1,length(MI));
    if model.name == "VAR"
        for m = 1:length(MI) 
            [~, nPhiIDs{m}, ~] = Null_model_VAR(MI(m), model.S, model.p(m), model.n, ["MMI"], ["PhiID"]);
        end
    else 
        error("Not a valid model type inserted, exiting."); 
    end

    qPhiIDs = zeros(16,length(MI));
    for m = 1:length(MI) 
    values = cellstruct2mat({atoms{m}});
    qPhiIDs(1:16,m) = CompQuantile(cellstruct2mat(nPhiIDs{m}),values);
    end

end